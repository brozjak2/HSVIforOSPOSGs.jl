var documenterSearchIndex = {"docs":
[{"location":"game_format/","page":"Game format","title":"Game format","text":"CurrentModule = HSVIforOSPOSGs","category":"page"},{"location":"game_format/#Game-format","page":"Game format","title":"Game format","text":"","category":"section"},{"location":"game_format/","page":"Game format","title":"Game format","text":"The games must be fed into the algorithm in compatible format, which is specified in games/game_format.txt:","category":"page"},{"location":"game_format/","page":"Game format","title":"Game format","text":"The file consists of the following sections:\n  1. Description of the game (number of states etc.)\n  2. Description of the game states\n  3. Names of actions of Player 1\n  4. Names of actions of Player 2\n  5. Names of observations\n  6. Enumeration of actions playable by Player 2 in each of the states\n  7. Enumeration of actions playable by Player 1 in each of the partition\n  8. Enumeration of game transitions ( Pr[o,s' | s,a,a'] )\n  9. Enumeration of rewards\n 1.  Initial belief\n\n1. Description of the game\n==========================\nThe first line of the file contains 8 numbers (in this order separated by\nwhite-space) as follows:\n  a) Number of states (|S|)\n  b) Number of \"partitions\". P1 (with imperfect information) always knows\n     the partition he is currently in. Partitions typically correspond to\n     the perfectly observable components of the state description (e.g.,\n     the location of P1).\n  c) Number of P1 actions (|A_1|)\n  d) Number of P2 actions (|A_2|)\n  e) Number of observations (|O|)\n  f) Number of transitions (i.e., lines in the section 7 of the file)\n  g) Number of rewards (i.e., lines in the section 8 of the file)\n  h) Discount factor (floating-point number)\n\n1. Description of the game states\n=================================\nThis section contains |S| lines containing a string and an integer sepa-\nrated by a white space. The string is the name of the i-th state (just\nfor convenience) and the integer denotes the partition the state belongs\nto (numbered from zero).\n  [state name] [partition ID]\n\n1. Names of actions of Player 1\n===============================\nThis section contains |A_1| strings on separate lines. (The names of the\nactions are just for the purpose of convenience.)\n\n1. Names of actions of Player 2\n===============================\nSimilar to section 2, except for describing actions of Player 2.\n\n1. Names of observations\n========================\nSimilar to sections 2 and 3. Each line represents the name of one obser-\nvation in the game.\n\n1. Enumeration of actions playable by Player 2\n==============================================\nThe solver assumes that there may be different set of actions that can be\nplayed in different states. This section contains |S| lines and i-th line\nenumerates actions that can be played by Player 2 in i-th state. The list\nof actions is a white-space separated integers [0, |A_2|-1].\n\n1. Enumeration of actions playable by Player 1\n==============================================\nAlso Player 1 can play different actions in different partitions. Every\nline in this section (they must match the number of partitions) denotes\nthe set of actions that can be played by Player 1 in the given partition\n(a list of [0, |A_1|-1] partitions.\n\n1. Enumeration of game transitions\n==================================\nEach line in this section describes one non-zero entry of the transition\nfunction. The format of each line is as follows:\n  [s] [a] [a'] [o] [s'] [prob]\nwhich describes that the probability to transition from [s] to [s'] and\ngenerating observation [o] when actions [a] (of P1) and [a'] has been\nplayed is [prob]. [s], [a], [a'], [o] and [s'] are zero-based indices of\nstates, actions and observations.\n\n1. Enumeration of rewards\n=========================\nEach line in this section describes one non-zero entry of the reward fun-\nction R. The format is as follows:\n  [s] [a] [a'] [reward]\nwhich means that the reward of Player 1 when taking actions [a] (of P1)\nand [a'] in the state [s] is [reward]. [s], [a] and [a'] are zero-based\nindices of states and actions. [reward] can be floating-point.\n\n1.  Initial belief\n==================\nThe initial belief is described by a single line containing white-space\nseparated numbers. The first number identifies the initial partition of\nthe game (Player 1 knows the partition). The remaining K numbers (where\nK is the number of states in the initial partition) denote the probabi-\nlity that the game starts in the given state of the partition.","category":"page"},{"location":"game_format/","page":"Game format","title":"Game format","text":"Below is an example games/pursuit-evasion/peg04.osposg that shows how a game in this format may look like (... skips over some inner lines of long sections):","category":"page"},{"location":"game_format/","page":"Game format","title":"Game format","text":"143 21 145 13 2 2671 2671 0.9500\n[[0:0,_0:1],_0:0] 4\n[[0:0,_0:1],_0:1] 4\n[[0:0,_0:1],_0:2] 4\n...\n[[1:0,_2:2],_0:2] 14\n[[1:2,_2:2],_0:2] 15\n[[2:1,_2:2],_0:2] 11\nend 20\n[PursuerAction{source=0:1,_target=1:1},_PursuerAction{source=0:2,_target=1:2}]\n[PursuerAction{source=0:1,_target=0:0},_PursuerAction{source=0:2,_target=1:2}]\n[PursuerAction{source=0:1,_target=0:0},_PursuerAction{source=0:2,_target=0:1}]\n...\n[PursuerAction{source=1:1,_target=2:1},_PursuerAction{source=2:1,_target=2:0}]\n[PursuerAction{source=1:1,_target=1:0},_PursuerAction{source=2:1,_target=2:2}]\n[PursuerAction{source=2:1,_target=1:1},_PursuerAction{source=1:1,_target=0:1}]\nend\ne0[0:0--1:0]\ne6[0:0--0:1]\ne1[0:1--1:1]\n...\ne5[1:2--2:2]\ne8[2:0--2:1]\ne11[2:1--2:2]\nend\nend\ncont\n0 1\n2 1 3\n4 3\n...\n4 3\n4 3\n12\n0 1 2 3 4 5\n6 7 8 9 10 11\n12 13 14 15 16 17 18 19 20 21 22 23\n...\n126 127 128 129 130 131\n132 133 134 135 136 137 138 139 140 141 142 143\n144\n9 0 7 0 142 1.000000\n82 64 11 1 30 1.000000\n22 52 9 1 16 1.000000\n...\n118 78 6 1 130 1.000000\n28 120 5 1 33 1.000000\n46 100 5 1 32 1.000000\n53 72 5 95.000000\n64 7 3 0.000000\n96 88 3 0.000000\n...\n133 70 1 0.000000\n137 83 7 95.000000\n57 143 9 0.000000\n4 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 0.0000 1.0000","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"CurrentModule = HSVIforOSPOSGs","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using HSVIforOSPOSGs: OSPOSG, HSVI, solve","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This page shows how to use the HSVIforOSPOSGs.","category":"page"},{"location":"manual/#Getting-started","page":"Manual","title":"Getting started","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"First, a game in .osgposg format must be loaded as OSPOSG:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"osposg = OSPOSG(\"../../games/pursuit-evasion/peg03.osposg\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"OSPOSG\nOSPOSG(path::AbstractString)","category":"page"},{"location":"manual/#HSVIforOSPOSGs.OSPOSG","page":"Manual","title":"HSVIforOSPOSGs.OSPOSG","text":"OSPOSG\n\nType for a one-sided partially observable stochastic game. Can be loaded from .osposg files.\n\n\n\n\n\n","category":"type"},{"location":"manual/#HSVIforOSPOSGs.OSPOSG-Tuple{AbstractString}","page":"Manual","title":"HSVIforOSPOSGs.OSPOSG","text":"OSPOSG(path::AbstractString)\n\nConstruct OSPOSG from .osposg file at path.\n\n\n\n\n\n","category":"method"},{"location":"manual/","page":"Manual","title":"Manual","text":"Then, HSVI algorithm must be instantiated/configured. Here we use HSVI with default parameters:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"hsvi = HSVI()","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For available parameters and their meaning see below:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"HSVI","category":"page"},{"location":"manual/#HSVIforOSPOSGs.HSVI","page":"Manual","title":"HSVIforOSPOSGs.HSVI","text":"HSVI\n\nHeuristic search value iteration solver for OSPOSGs.\n\nThe constructor takes following keyword arguments:\n\nneighborhood: parameter that guarantees Lipschitz continuity and convergence of the algorithm\npresolve_epsilon: precision the solver is trying to achieve during presolve phase\npresolve_time_limit: time limit for the presolve phase in seconds\noptimizer_factory: function that returns optimizer compatible with JuMP.Model to be used as LP solver\n\n\n\n\n\n","category":"type"},{"location":"manual/","page":"Manual","title":"Manual","text":"The neigborhood parameter D of HSVI must be within these bounds","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"0  D  frac(1  gamma) varepsilon2 delta","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"for the algorithm to have convergence guarantees, where gamma is discount factor, varepsilon is specified gap and delta is Lipschitz delta of the game.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"After loading the game and configuring the algorithm we can start solving by running solve:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"recorder = solve(osposg, hsvi, 1.0, 60.0)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"solve","category":"page"},{"location":"manual/#HSVIforOSPOSGs.solve","page":"Manual","title":"HSVIforOSPOSGs.solve","text":"solve(osposg::OSPOSG, hsvi::HSVI, epsilon::Float64, time_limit::Float64)\n\nRun hsvi solver on osposg game with time limit time_limit aiming for gap of at most epsilon in initial belief.\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Manual","title":"Manual","text":"The recorder contains records of the algorithm progress after each iteration and can be used for further examination or presentation of results.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Recorder","category":"page"},{"location":"manual/#HSVIforOSPOSGs.Recorder","page":"Manual","title":"HSVIforOSPOSGs.Recorder","text":"Recorder\n\nStores the solver statistics after each iteration.\n\n\n\n\n\n","category":"type"},{"location":"manual/#LP-Solvers","page":"Manual","title":"LP Solvers","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"HSVIforOSPOSGs uses GLPK as a JuMP solver for linear programs by default because it is open-source and easily installable through standalone Julia package. However, note that the LP models being solved in HSVI for OSPOSGs are quite complex and GLPK might get stuck on some of them or report them as being unfeasible (although they should be feasible). Therefore, it is recommended to use more powerful solvers (such as CPLEX, Gurobi, etc.). However, installing them is not as straightforward and often requires 3rd party binary and/or proprietary license. If you wish to use different solver you can do so by installing the JuMP wrapper for the given solver (refer to installation instructions at CPLEX.jl, Gurobi.jl, etc.) and then pass the optimizer factory into HSVI constructor:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using CPLEX\n\nHSVI(optimizer_factory=() -> CPLEX.Optimizer())","category":"page"},{"location":"manual/#Logging-level","page":"Manual","title":"Logging level","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"This package utilizes Julia logging facilities to communicate the progress of the algorithm to the user. By default only info, warning and error messages are displayed. To display more detailed debuging info, use the following before running the algorithm:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using Logging\n\nglobal_logger(ConsoleLogger(stdout, Logging.Debug))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"On the contrary, to disable info logging use:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"global_logger(ConsoleLogger(stdout, Logging.Warn))","category":"page"},{"location":"manual/#Examples","page":"Manual","title":"Examples","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Additional examples on how to configure and run the algorithm are provided in the scripts directory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = HSVIforOSPOSGs","category":"page"},{"location":"#HSVIforOSPOSGs.jl","page":"Home","title":"HSVIforOSPOSGs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is documentation for HSVIforOSPOSGs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HSVIforOSPOSGs is unofficial Julia implementation of heuristic search value iteration (HSVI) algorithm for one-sided partially observable stochastic games (OSPOSGs) as described in Heuristic Search Value Iteration for One-Sided Partially Observable Stochastic Games. OSPOSGs can be seen as a generalization of Partially observable Markov decision processes (POMDPs) and Stochastic games, where one agent has imperfect information while their opponent has full knowledge of the current situation. The algorithm is multi-agent adaptation of Heuristic Search Value Iteration for POMDPs.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Manual\nGetting started\nLP Solvers\nLogging level\nExamples\nGame format","category":"page"}]
}
